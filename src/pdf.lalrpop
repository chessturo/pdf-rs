use crate::ast::object;
use crate::lexer::*;
use crate::parser_helper::*;

grammar<'input>(input: &'input [u8]);

pub RawPdfStr: Vec<u8> = RawStrDelimOpen <RawStrContent?> RawStrDelimClose =>
    handle_raw_str_escapes(<>.unwrap_or(&[]));

// TODO: Don't `.unwrap()` if there's invalid hex characters
pub HexPdfStr: Vec<u8> = "<" <HexStrContent?> ">" => handle_hex_str(<>.unwrap_or(&[])).unwrap();
pub Name: Vec<u8> = NameTok => handle_name_escapes(<>).unwrap();

pub Boolean: bool = {
    "true" => true,
    "false" => false,
}

pub Number: object::Number = {
    <NumberTok> => handle_number(<>),
}

extern {
    type Location = usize;
    type Error = PdfLexError<'input>;

    enum Tok<'input> {
        RawStrDelimOpen => Tok::RawStrDelimOpen,
        RawStrDelimClose => Tok::RawStrDelimClose,
        RawStrContent => Tok::RawStrContent(<&'input [u8]>),

        "<" => Tok::HexStrDelimOpen,
        ">" => Tok::HexStrDelimClose,
        HexStrContent => Tok::HexStrContent(<&'input [u8]>),

        NameTok => Tok::Name(<&'input [u8]>),

        "true" => Tok::True,
        "false" => Tok::False,

        NumberTok => Tok::Number(<&'input [u8]>),

        UnknownTok => Tok::UnknownTok(<&'input [u8]>),
    }
}
